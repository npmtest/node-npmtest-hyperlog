{"/home/travis/build/npmtest/node-npmtest-hyperlog/test.js":"/* istanbul instrument in package npmtest_hyperlog */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hyperlog/lib.npmtest_hyperlog.js":"/* istanbul instrument in package npmtest_hyperlog */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_hyperlog = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_hyperlog = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-hyperlog/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-hyperlog && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_hyperlog */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_hyperlog\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_hyperlog.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_hyperlog.rollup.js'] =\n            local.assetsDict['/assets.npmtest_hyperlog.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_hyperlog.__dirname + '/lib.npmtest_hyperlog.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/index.js":"var after = require('after-all')\nvar lexint = require('lexicographic-integer')\nvar collect = require('stream-collector')\nvar through = require('through2')\nvar pump = require('pump')\nvar from = require('from2')\nvar mutexify = require('mutexify')\nvar cuid = require('cuid')\nvar logs = require('level-logs')\nvar events = require('events')\nvar util = require('util')\nvar enumerate = require('level-enumerate')\nvar replicate = require('./lib/replicate')\nvar messages = require('./lib/messages')\nvar hash = require('./lib/hash')\nvar encoder = require('./lib/encode')\nvar defined = require('defined')\nvar parallel = require('run-parallel')\nvar waterfall = require('run-waterfall')\n\nvar ID = '!!id'\nvar CHANGES = '!changes!'\nvar NODES = '!nodes!'\nvar HEADS = '!heads!'\n\nvar INVALID_SIGNATURE = new Error('Invalid signature')\nvar CHECKSUM_MISMATCH = new Error('Checksum mismatch')\nvar INVALID_LOG = new Error('Invalid log sequence')\n\nINVALID_LOG.notFound = true\nINVALID_LOG.status = 404\n\nvar noop = function () {}\n\nvar Hyperlog = function (db, opts) {\n  if (!(this instanceof Hyperlog)) return new Hyperlog(db, opts)\n  if (!opts) opts = {}\n\n  events.EventEmitter.call(this)\n\n  this.id = defined(opts.id, null)\n  this.enumerate = enumerate(db, {prefix: 'enum'})\n  this.db = db\n  this.logs = logs(db, {prefix: 'logs', valueEncoding: messages.Entry})\n  this.lock = defined(opts.lock, mutexify())\n  this.changes = 0\n  this.setMaxListeners(0)\n  this.valueEncoding = defined(opts.valueEncoding, opts.encoding, 'binary')\n  this.identity = defined(opts.identity, null)\n  this.verify = defined(opts.verify, null)\n  this.sign = defined(opts.sign, null)\n  this.hash = defined(opts.hash, hash)\n  this.asyncHash = defined(opts.asyncHash, null)\n\n  // Retrieve this hyperlog instance's unique ID.\n  var self = this\n  var getId = defined(opts.getId, function (cb) {\n    db.get(ID, {valueEncoding: 'utf-8'}, function (_, id) {\n      if (id) return cb(null, id)\n      id = cuid()\n      db.put(ID, id, function () {\n        cb(null, id)\n      })\n    })\n  })\n\n  // Startup logic to..\n  // 1. Determine & record the largest change # in the db.\n  // 2. Determine this hyperlog db's local ID.\n  //\n  // This is behind a lock in order to ensure that no hyperlog operations\n  // can be performed -- these two values MUST be known before any\n  // hyperlog usage may occur.\n  this.lock(function (release) {\n    collect(db.createKeyStream({gt: CHANGES, lt: CHANGES + '~', reverse: true, limit: 1}), function (_, keys) {\n      self.changes = Math.max(self.changes, keys && keys.length ? lexint.unpack(keys[0].split('!').pop(), 'hex') : 0)\n      if (self.id) return release()\n      getId(function (_, id) {\n        self.id = id || cuid()\n        release()\n      })\n    })\n  })\n}\n\nutil.inherits(Hyperlog, events.EventEmitter)\n\n// Call callback 'cb' once the hyperlog is ready for use (knows some\n// fundamental properties about itself from the leveldb). If it's already\n// ready, cb is called immediately.\nHyperlog.prototype.ready = function (cb) {\n  if (this.id) return cb()\n  this.lock(function (release) {\n    release()\n    cb()\n  })\n}\n\n// Returns a readable stream of all hyperlog heads. That is, all nodes that no\n// other nodes link to.\nHyperlog.prototype.heads = function (opts, cb) {\n  var self = this\n  if (!opts) opts = {}\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  var rs = this.db.createValueStream({\n    gt: HEADS,\n    lt: HEADS + '~',\n    valueEncoding: 'utf-8'\n  })\n\n  var format = through.obj(function (key, enc, cb) {\n    self.get(key, opts, cb)\n  })\n\n  return collect(pump(rs, format), cb)\n}\n\n// Retrieve a single, specific node, given its key.\nHyperlog.prototype.get = function (key, opts, cb) {\n  if (!opts) opts = {}\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  var self = this\n  this.db.get(NODES + key, {valueEncoding: 'binary'}, function (err, buf) {\n    if (err) return cb(err)\n    var node = messages.Node.decode(buf)\n    node.value = encoder.decode(node.value, opts.valueEncoding || self.valueEncoding)\n    cb(null, node)\n  })\n}\n\n// Utility function to be used in a nodes.reduce() to determine the largest\n// change # present.\nvar maxChange = function (max, cur) {\n  return Math.max(max, cur.change)\n}\n\n// Consumes either a string or a hyperlog node and returns its key.\nvar toKey = function (link) {\n  return typeof link !== 'string' ? link.key : link\n}\n\n// Adds a new hyperlog node to an existing array of leveldb batch insertions.\n// This includes performing crypto signing and verification.\n// Performs deduplication; returns the existing node if alreay present in the hyperlog.\nvar addBatchAndDedupe = function (dag, node, logLinks, batch, opts, cb) {\n  if (opts.hash && node.key !== opts.hash) return cb(CHECKSUM_MISMATCH)\n  if (opts.seq && node.seq !== opts.seq) return cb(INVALID_LOG)\n\n  var log = {\n    change: node.change,\n    node: node.key,\n    links: logLinks\n  }\n\n  var onclone = function (clone) {\n    if (!opts.log) return cb(null, clone, [])\n    batch.push({type: 'put', key: dag.logs.key(node.log, node.seq), value: messages.Entry.encode(log)})\n    cb(null, clone)\n  }\n\n  var done = function () {\n    dag.get(node.key, { valueEncoding: 'binary' }, function (_, clone) {\n      // This node already exists somewhere in the hyperlog; add it to the\n      // log's append-only log, but don't insert it again.\n      if (clone) return onclone(clone)\n\n      var links = node.links\n      for (var i = 0; i < links.length; i++) batch.push({type: 'del', key: HEADS + links[i]})\n      batch.push({type: 'put', key: CHANGES + lexint.pack(node.change, 'hex'), value: node.key})\n      batch.push({type: 'put', key: NODES + node.key, value: messages.Node.encode(node)})\n      batch.push({type: 'put', key: HEADS + node.key, value: node.key})\n      batch.push({type: 'put', key: dag.logs.key(node.log, node.seq), value: messages.Entry.encode(log)})\n\n      cb(null, node)\n    })\n  }\n\n  // Local node; sign it.\n  if (node.log === dag.id) {\n    if (!dag.sign || node.signature) return done()\n    dag.sign(node, function (err, sig) {\n      if (err) return cb(err)\n      if (!node.identity) node.identity = dag.identity\n      node.signature = sig\n      done()\n    })\n  // Remote node; verify it.\n  } else {\n    if (!dag.verify) return done()\n    dag.verify(node, function (err, valid) {\n      if (err) return cb(err)\n      if (!valid) return cb(INVALID_SIGNATURE)\n      done()\n    })\n  }\n}\n\nvar getLinks = function (dag, id, links, cb) {\n  var logLinks = []\n  var nextLink = function () {\n    var cb = next()\n    return function (err, link) {\n      if (err) return cb(err)\n      if (link.log !== id && logLinks.indexOf(link.log) === -1) logLinks.push(link.log)\n      cb(null)\n    }\n  }\n  var next = after(function (err) {\n    if (err) cb(err)\n    else cb(null, logLinks)\n  })\n\n  for (var i = 0; i < links.length; i++) {\n    dag.get(links[i], nextLink())\n  }\n}\n\n// Produce a readable stream of all nodes added from this point onward, in\n// topographic order.\nvar createLiveStream = function (dag, opts) {\n  var since = opts.since || 0\n  var limit = opts.limit || -1\n  var wait = null\n\n  var read = function (size, cb) {\n    if (dag.changes <= since) {\n      wait = cb\n      return\n    }\n\n    if (!limit) return cb(null, null)\n\n    dag.db.get(CHANGES + lexint.pack(since + 1, 'hex'), function (err, hash) {\n      if (err) return cb(err)\n      dag.get(hash, opts, function (err, node) {\n        if (err) return cb(err)\n        since = node.change\n        if (limit !== -1) limit--\n        cb(null, node)\n      })\n    })\n  }\n\n  var kick = function () {\n    if (!wait) return\n    var cb = wait\n    wait = null\n    read(0, cb)\n  }\n\n  dag.on('add', kick)\n  dag.ready(kick)\n\n  var rs = from.obj(read)\n\n  rs.once('close', function () {\n    dag.removeListener('add', kick)\n  })\n\n  return rs\n}\n\n// Produce a readable stream of nodes in the hyperlog, in topographic order.\nHyperlog.prototype.createReadStream = function (opts) {\n  if (!opts) opts = {}\n  if (opts.tail) {\n    opts.since = this.changes\n  }\n  if (opts.live) return createLiveStream(this, opts)\n\n  var self = this\n  var since = opts.since || 0\n  var until = opts.until || 0\n\n  var keys = this.db.createValueStream({\n    gt: CHANGES + lexint.pack(since, 'hex'),\n    lt: CHANGES + (until ? lexint.pack(until, 'hex') : '~'),\n    valueEncoding: 'utf-8',\n    reverse: opts.reverse,\n    limit: opts.limit\n  })\n\n  var get = function (key, enc, cb) {\n    self.get(key, opts, cb)\n  }\n\n  return pump(keys, through.obj(get))\n}\n\nHyperlog.prototype.replicate =\nHyperlog.prototype.createReplicationStream = function (opts) {\n  return replicate(this, opts)\n}\n\nHyperlog.prototype.add = function (links, value, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!cb) cb = noop\n  this.batch([{links: links, value: value}], opts, function (err, nodes) {\n    if (err) cb(err)\n    else cb(null, nodes[0])\n  })\n}\n\nHyperlog.prototype.batch = function (docs, opts, cb) {\n  // 0. preamble\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!cb) cb = noop\n  if (!opts) opts = {}\n\n  // Bail asynchronously; nothing to add.\n  if (docs.length === 0) return process.nextTick(function () { cb(null, []) })\n\n  var self = this\n  var id = opts.log || self.id\n  opts.log = id\n\n  var logLinks = {}\n  var lockRelease = null\n  var latestSeq\n\n  // Bubble up errors on non-batch (1 element) calls.\n  var bubbleUpErrors = false\n  if (docs.length === 1) {\n    bubbleUpErrors = true\n  }\n\n  // 1. construct initial hyperlog \"node\" for each of \"docs\"\n  var nodes = docs.map(function (doc) {\n    return constructInitialNode(doc, opts)\n  })\n\n  // 2. emit all preadd events\n  nodes.forEach(function (node) {\n    self.emit('preadd', node)\n  })\n\n  waterfall([\n    // 3. lock the hyperlog (if needed)\n    // 4. wait until the hyperlog is 'ready'\n    // 5. retrieve the seq# of this hyperlog's head\n    lockAndGetSeqNumber,\n\n    // 3. hash (async/sync) all nodes\n    // 4. retrieve + set 'getLinks' for each node\n    function (seq, release, done) {\n      lockRelease = release\n      latestSeq = seq\n\n      hashNodesAndFindLinks(nodes, done)\n    },\n\n    // 8. dedupe the node against the params AND the hyperlog (in sequence)\n    function (nodes, done) {\n      dedupeNodes(nodes, latestSeq, done)\n    },\n\n    // 9. create each node's leveldb batch operation object\n    function (nodes, done) {\n      computeBatchNodeOperations(nodes, done)\n    },\n\n    // 10. perform the leveldb batch op\n    function (nodes, batchOps, done) {\n      self.db.batch(batchOps, function (err) {\n        if (err) {\n          nodes.forEach(rejectNode)\n          return done(err)\n        }\n        done(null, nodes)\n      })\n    },\n\n    // 11. update the hyperlog's change#\n    // 12. emit all add/reject events\n    function (nodes, done) {\n      self.changes = nodes.reduce(maxChange, self.changes)\n      done(null, nodes)\n    }\n  ], function (err, nodes) {\n    // release lock, if necessary\n    if (lockRelease) return lockRelease(onUnlocked, err)\n    onUnlocked(err)\n\n    function onUnlocked (err) {\n      // Error; all nodes were rejected.\n      if (err) return cb(err)\n\n      // Emit add events.\n      nodes.forEach(function (node) {\n        self.emit('add', node)\n      })\n\n      cb(null, nodes)\n    }\n  })\n\n  function rejectNode (node) {\n    self.emit('reject', node)\n  }\n\n  // Hashes and finds links for the given nodes. If some nodes fail to hash to\n  // have their links found, they are rejected and not returned in the results.\n  function hashNodesAndFindLinks (nodes, done) {\n    var goodNodes = []\n\n    parallel(\n      nodes.map(function (node) {\n        return function (done) {\n          hashNode(node, function (err, key) {\n            if (err) {\n              rejectNode(node)\n              return done(bubbleUpErrors ? err : null)\n            }\n            node.key = key\n\n            getLinks(self, id, node.links, function (err, links) {\n              if (err) {\n                rejectNode(node)\n                return done(bubbleUpErrors ? err : null)\n              }\n              logLinks[node.key] = links\n\n              if (!node.log) node.log = self.id\n\n              goodNodes.push(node)\n              done()\n            })\n          })\n        }\n      }),\n      function (err) {\n        done(err, goodNodes)\n      }\n    )\n  }\n\n  function lockAndGetSeqNumber (done) {\n    if (opts.release) onlocked(opts.release)\n    else self.lock(onlocked)\n\n    function onlocked (release) {\n      self.ready(function () {\n        self.logs.head(id, function (err, seq) {\n          if (err) return release(cb, err)\n          done(null, seq, release)\n        })\n      })\n    }\n  }\n\n  function dedupeNodes (nodes, seq, done) {\n    var goodNodes = []\n\n    var added = nodes.length > 1 ? {} : null\n    var seqIdx = 1\n    var changeIdx = 1\n\n    waterfall(\n      nodes.map(function (node) {\n        return function (done) {\n          dedupeNode(node, done)\n        }\n      }),\n      function (err) {\n        done(err, goodNodes)\n      }\n    )\n\n    function dedupeNode (node, done) {\n      // Check if the to-be-added node already exists in the hyperlog.\n      self.get(node.key, function (_, clone) {\n        // It already exists\n        if (clone) {\n          node.seq = seq + (seqIdx++)\n          node.change = clone.change\n        // It already exists; it was added in this batch op earlier on.\n        } else if (added && added[node.key]) {\n          node.seq = added[node.key].seq\n          node.change = added[node.key].change\n          rejectNode(node)\n          return done()\n        } else {\n          // new node across all logs\n          node.seq = seq + (seqIdx++)\n          node.change = self.changes + (changeIdx++)\n        }\n\n        if (added) added[node.key] = node\n\n        goodNodes.push(node)\n\n        done()\n      })\n    }\n  }\n\n  function computeBatchNodeOperations (nodes, done) {\n    var batch = []\n    var goodNodes = []\n\n    waterfall(\n      nodes.map(function (node) {\n        return function (done) {\n          computeNodeBatchOp(node, function (err, ops) {\n            if (err) {\n              rejectNode(node)\n              return done(bubbleUpErrors ? err : null)\n            }\n            batch = batch.concat(ops)\n            goodNodes.push(node)\n            done()\n          })\n        }\n      }),\n      function (err) {\n        if (err) return done(err)\n        done(null, nodes, batch)\n      }\n    )\n\n    // Create a new leveldb batch operation for this node.\n    function computeNodeBatchOp (node, done) {\n      var batch = []\n      var links = logLinks[node.key]\n      addBatchAndDedupe(self, node, links, batch, opts, function (err, newNode) {\n        if (err) return done(err)\n        newNode.value = encoder.decode(newNode.value, opts.valueEncoding || self.valueEncoding)\n        done(null, batch)\n      })\n    }\n  }\n\n  function constructInitialNode (doc, opts) {\n    var links = doc.links || []\n    if (!Array.isArray(links)) links = [links]\n    links = links.map(toKey)\n\n    var encodedValue = encoder.encode(doc.value, opts.valueEncoding || self.valueEncoding)\n    return {\n      log: opts.log || self.id,\n      key: null,\n      identity: doc.identity || opts.identity || null,\n      signature: opts.signature || null,\n      value: encodedValue,\n      links: links\n    }\n  }\n\n  function hashNode (node, done) {\n    if (self.asyncHash) {\n      self.asyncHash(node.links, node.value, done)\n    } else {\n      var key = self.hash(node.links, node.value)\n      done(null, key)\n    }\n  }\n}\n\nHyperlog.prototype.append = function (value, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!cb) cb = noop\n  if (!opts) opts = {}\n  var self = this\n\n  this.lock(function (release) {\n    self.heads(function (err, heads) {\n      if (err) return release(cb, err)\n      opts.release = release\n      self.add(heads, value, opts, cb)\n    })\n  })\n}\n\nmodule.exports = Hyperlog\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/replicate.js":"var through = require('through2')\nvar pump = require('pump')\nvar bitfield = require('bitfield')\nvar protocol = require('./protocol')\nvar sortedQueue = require('./sorted-queue')\nvar encoder = require('./encode.js')\n\nvar noop = function () {}\nvar noarr = []\n\nvar MAX_BITFIELD = 10 * 1024 * 1024 // arbitrary high number\n\nmodule.exports = function (dag, opts) {\n  if (!opts) opts = {}\n\n  var stream = protocol(opts)\n  var mode = opts.mode || 'sync'\n\n  // Bitfield to ensure that the nodes of each log in the hyperlog is only sent\n  // once.\n  var pushing = bitfield(1024, {grow: MAX_BITFIELD})\n\n  // The largest change # known to this log when replication begins.\n  var changes = 0\n\n  var missing = 0\n\n  var done = false\n  var remoteSentWants = false\n  var remoteSentHeads = false\n  var localSentWants = false\n  var localSentHeads = false\n\n  var live = opts.live\n\n  // Local nodes yet to be sent.\n  var outgoing = sortedQueue()\n  // Remote nodes yet to be added to this hyperlog.\n  var incoming = sortedQueue()\n\n  // Asynchronous loop to continue sending nodes from a log in sequence from\n  // low seq # to its highest seq #.\n  outgoing.pull(function loop (entry) {\n    dag.get(entry.node, {valueEncoding: 'binary'}, function (err, node) {\n      if (err) return stream.destroy(err)\n\n      if (entry.log && (node.log !== entry.log || node.seq !== entry.seq)) { // deduplicated\n        node.log = entry.log\n        node.seq = entry.seq\n      }\n\n      stream.emit('push')\n      stream.node(node, function (err) {\n        if (err) return stream.destroy(err)\n        sendNode(node.log, node.seq + 1, function (err) {\n          if (err) return stream.destroy(err)\n          outgoing.pull(loop)\n        })\n      })\n    })\n  })\n\n  var pipe = function (a, b, cb) {\n    var destroy = function () {\n      a.destroy()\n    }\n\n    stream.on('close', destroy)\n    stream.on('finish', destroy)\n\n    a.on('end', function () {\n      stream.removeListener('close', destroy)\n      stream.removeListener('finish', destroy)\n    })\n\n    return pump(a, b, cb)\n  }\n\n  // For live replication. Reads live from the local hyperlog and continues to\n  // send new nodes to the other end.\n  var sendChanges = function () {\n    var write = function (node, enc, cb) {\n      node.value = encoder.encode(node.value, dag.valueEncoding)\n      stream.node(node, cb)\n    }\n\n    stream.emit('live')\n    pipe(dag.createReadStream({since: changes, live: true}), through.obj(write))\n  }\n\n  // Check if replication is finished.\n  var update = function (cb) {\n    if (done || !localSentWants || !localSentHeads || !remoteSentWants || !remoteSentHeads) return cb()\n    done = true\n    if (!live) return stream.finalize(cb)\n    sendChanges()\n    cb()\n  }\n\n  // Inform the other side that we've requested all of the nodes we want.\n  var sentWants = function (cb) {\n    localSentWants = true\n    stream.sentWants()\n    update(cb)\n  }\n\n  // Inform the other side that we've sent all of the heads we have.\n  var sentHeads = function (cb) {\n    localSentHeads = true\n    stream.sentHeads()\n    update(cb)\n  }\n\n  // Send a specific entry in a specific log to the other side.\n  // If the node links to other nodes, inform the other side we have those,\n  // too.\n  var sendNode = function (log, seq, cb) {\n    dag.logs.get(log, seq, function (err, entry) {\n      if (err && err.notFound) return cb()\n      if (err) return cb(err)\n      if (entry.change > changes) return cb() // ensure snapshot\n\n      entry.log = log\n      entry.seq = seq\n\n      var i = 0\n      var loop = function () {\n        if (i < entry.links.length) return sendHave(entry.links[i++], loop)\n        entry.links = noarr // premature opt: less mem yo\n        outgoing.push(entry, cb)\n      }\n\n      loop()\n    })\n  }\n\n  // Add a received remote node to our local hyperlog.\n  // It is normal for the insertion to sometimes fail: we may have received a\n  // node that depends on another node from a log we haven't yet received. If\n  // so, enqueue it into 'incoming' and continue trying to re-insert it until\n  // its dependencies are also present.\n  var receiveNode = function (node, cb) {\n    var opts = {\n      hash: node.key,\n      log: node.log,\n      seq: node.seq,\n      identity: node.identity,\n      signature: node.signature,\n      valueEncoding: 'binary'\n    }\n    dag.add(node.links, node.value, opts, function (err) {\n      if (!err) return afterAdd(cb)\n      if (!err.notFound) return cb(err)\n      incoming.push(node, cb)\n    })\n  }\n\n  var afterAdd = function (cb) {\n    stream.emit('pull')\n    if (!localSentWants && !--missing) return sentWants(cb)\n    if (!incoming.length) return cb()\n    incoming.pull(function (node) {\n      receiveNode(node, cb)\n    })\n  }\n\n  var sendHave = function (log, cb) {\n    dag.enumerate(log, function (err, idx) {\n      if (err) return cb(err)\n\n      // Don't send the same log twice.\n      if (pushing.get(idx)) return cb()\n      pushing.set(idx, true)\n\n      dag.logs.head(log, function (err, seq) {\n        if (err) return cb(err)\n        dag.logs.get(log, seq, function loop (err, entry) { // ensure snapshot\n          if (err && err.notFound) return cb()\n          if (err) return cb(err)\n          if (entry.change > changes) return dag.logs.get(log, seq - 1, loop)\n          stream.have({log: log, seq: seq}, cb)\n        })\n      })\n    })\n  }\n\n  stream.once('sentHeads', function (cb) {\n    if (!localSentWants && !missing) sentWants(noop)\n    remoteSentHeads = true\n    update(cb)\n  })\n\n  stream.once('sentWants', function (cb) {\n    remoteSentWants = true\n    update(cb)\n  })\n\n  stream.on('want', function (head, cb) {\n    sendNode(head.log, head.seq + 1, cb)\n  })\n\n  stream.on('have', function (head, cb) {\n    dag.logs.head(head.log, function (err, seq) {\n      if (err) return cb(err)\n      if (seq >= head.seq) return cb()\n      missing += (head.seq - seq)\n      stream.want({log: head.log, seq: seq}, cb)\n    })\n  })\n\n  stream.on('node', receiveNode)\n\n  // start the handshake\n\n  stream.on('handshake', function (handshake, cb) {\n    var remoteMode = handshake.mode\n\n    if (remoteMode !== 'pull' && remoteMode !== 'push' && remoteMode !== 'sync') return cb(new Error('Remote uses invalid mode: ' + remoteMode))\n    if (remoteMode === 'pull' && mode === 'pull') return cb(new Error('Remote and local are both pulling'))\n    if (remoteMode === 'push' && mode === 'push') return cb(new Error('Remote and local are both pushing'))\n\n    remoteSentWants = remoteMode === 'push'\n    remoteSentHeads = remoteMode === 'pull'\n    localSentWants = mode === 'push' || remoteMode === 'pull'\n    localSentHeads = mode === 'pull' || remoteMode === 'push'\n\n    if (handshake.metadata) stream.emit('metadata', handshake.metadata)\n    if (!live) live = handshake.live\n    if (localSentHeads) return update(cb)\n\n    var write = function (node, enc, cb) {\n      sendHave(node.log, cb)\n    }\n\n    dag.lock(function (release) { // TODO: don't lock here. figure out how to snapshot the heads to a change instead\n      changes = dag.changes\n      pipe(dag.heads(), through.obj(write), function (err) {\n        release()\n        if (err) return cb(err)\n        sentHeads(cb)\n      })\n    })\n  })\n\n  stream.handshake({version: 1, mode: opts.mode, metadata: opts.metadata, live: live})\n\n  return stream\n}\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/protocol.js":"var Duplexify = require('duplexify')\nvar util = require('util')\nvar lpstream = require('length-prefixed-stream')\nvar through = require('through2')\nvar debug = require('debug')('hyperlog-replicate')\nvar messages = require('./messages')\n\nvar empty = {\n  encodingLength: function () {\n    return 0\n  },\n  encode: function (data, buf, offset) {\n    return buf\n  }\n}\n\nvar Protocol = function (opts) {\n  if (!(this instanceof Protocol)) return new Protocol(opts)\n\n  var frame = !opts || opts.frame !== false\n\n  this._encoder = frame ? lpstream.encode() : through.obj()\n  this._decoder = frame ? lpstream.decode() : through.obj()\n  this._finalize = opts.finalize ? opts.finalize : function (cb) { cb() }\n  this._process = opts.process || null\n\n  var self = this\n  var parse = through.obj(function (data, enc, cb) {\n    self._decode(data, cb)\n  })\n\n  parse.on('error', function (err) {\n    self.destroy(err)\n  })\n\n  this.on('end', function () {\n    debug('ended')\n    self.end()\n  })\n\n  this.on('finish', function () {\n    debug('finished')\n    self.finalize()\n  })\n\n  this._decoder.pipe(parse)\n\n  if (this._process) {\n    this._process.pipe(through.obj(function (node, enc, cb) {\n      self.emit('node', node, cb) || cb()\n    }))\n  }\n\n  var hwm = opts.highWaterMark || 16\n  Duplexify.call(this, this._decoder, this._encoder, frame ? {} : {objectMode: true, highWaterMark: hwm})\n}\n\nutil.inherits(Protocol, Duplexify)\n\nProtocol.prototype.handshake = function (handshake, cb) {\n  debug('sending handshake')\n  this._encode(0, messages.Handshake, handshake, cb)\n}\n\nProtocol.prototype.have = function (have, cb) {\n  debug('sending have')\n  this._encode(1, messages.Log, have, cb)\n}\n\nProtocol.prototype.want = function (want, cb) {\n  debug('sending want')\n  this._encode(2, messages.Log, want, cb)\n}\n\nProtocol.prototype.node = function (node, cb) {\n  debug('sending node')\n  this._encode(3, messages.Node, node, cb)\n}\n\nProtocol.prototype.sentHeads = function (cb) {\n  debug('sending sentHeads')\n  this._encode(4, empty, null, cb)\n}\n\nProtocol.prototype.sentWants = function (cb) {\n  debug('sending sentWants')\n  this._encode(5, empty, null, cb)\n}\n\nProtocol.prototype.finalize = function (cb) {\n  var self = this\n  this._finalize(function (err) {\n    debug('ending')\n    if (err) return self.destroy(err)\n    self._encoder.end(cb)\n  })\n}\n\nProtocol.prototype._encode = function (type, enc, data, cb) {\n  var buf = new Buffer(enc.encodingLength(data) + 1)\n  buf[0] = type\n  enc.encode(data, buf, 1)\n  this._encoder.write(buf, cb)\n}\n\nvar decodeMessage = function (data) {\n  switch (data[0]) {\n    case 0: return messages.Handshake.decode(data, 1)\n    case 1: return messages.Log.decode(data, 1)\n    case 2: return messages.Log.decode(data, 1)\n    case 3: return messages.Node.decode(data, 1)\n  }\n  return null\n}\n\nProtocol.prototype._decode = function (data, cb) {\n  try {\n    var msg = decodeMessage(data)\n  } catch (err) {\n    return cb(err)\n  }\n\n  switch (data[0]) {\n    case 0:\n      debug('receiving handshake')\n      return this.emit('handshake', msg, cb) || cb()\n\n    case 1:\n      debug('receiving have')\n      return this.emit('have', msg, cb) || cb()\n\n    case 2:\n      debug('receiving want')\n      return this.emit('want', msg, cb) || cb()\n\n    case 3:\n      debug('receiving node')\n      return this._process ? this._process.write(msg, cb) : (this.emit('node', msg, cb) || cb())\n\n    case 4:\n      debug('receiving sentHeads')\n      return this.emit('sentHeads', cb) || cb()\n\n    case 5:\n      debug('receiving sentWants')\n      return this.emit('sentWants', cb) || cb()\n  }\n\n  cb()\n}\n\nmodule.exports = Protocol\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/messages.js":"var protobuf = require('protocol-buffers')\nvar fs = require('fs')\nvar path = require('path')\n\nmodule.exports = protobuf(fs.readFileSync(path.join(__dirname, '..', 'schema.proto'), 'utf-8'))\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/sorted-queue.js":"// A queue of hyperlog nodes that is sorted by the nodes' change #. The node\n// with the lowest change # will be the first dequeued.\n//\n// TODO: buffer to leveldb if the queue becomes large\nvar SortedQueue = function () {\n  if (!(this instanceof SortedQueue)) return new SortedQueue()\n  this.list = []\n  this.wait = null\n  this.length = 0\n}\n\nSortedQueue.prototype.push = function (entry, cb) {\n  var i = indexOf(this.list, entry.change)\n  if (i === this.list.length) this.list.push(entry)\n  else this.list.splice(i, 0, entry)\n  this.length++\n\n  if (this.wait) this.pull(this.wait)\n  if (cb) cb()\n}\n\nSortedQueue.prototype.pull = function (cb) {\n  if (!this.list.length) {\n    this.wait = cb\n    return\n  }\n\n  this.wait = null\n\n  var next = this.list.shift()\n  this.length--\n\n  cb(next)\n}\n\nfunction indexOf (list, change) {\n  var low = 0\n  var high = list.length\n  var mid = 0\n\n  while (low < high) {\n    mid = (low + high) >> 1\n    if (change < list[mid].change) high = mid\n    else low = mid + 1\n  }\n\n  return low\n}\n\nmodule.exports = SortedQueue\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/encode.js":"exports.encode = function (value, enc) {\n  if (typeof enc === 'object' && enc.encode) {\n    value = enc.encode(value)\n  } else if (enc === 'json') {\n    value = Buffer(JSON.stringify(value))\n  }\n  if (typeof value === 'string') value = new Buffer(value)\n  return value\n}\n\nexports.decode = function (value, enc) {\n  if (typeof enc === 'object' && enc.decode) {\n    return enc.decode(value)\n  } else if (enc === 'json') {\n    return JSON.parse(value.toString())\n  } else if (enc === 'utf-8' || enc === 'utf8') {\n    return value.toString()\n  }\n  return value\n}\n","/home/travis/build/npmtest/node-npmtest-hyperlog/node_modules/hyperlog/lib/hash.js":"var framedHash = require('framed-hash')\nvar empty = new Buffer(0)\n\nmodule.exports = function (links, value) {\n  var hash = framedHash('sha256')\n  for (var i = 0; i < links.length; i++) hash.update(links[i])\n  hash.update(value || empty)\n  return hash.digest('hex')\n}\n"}